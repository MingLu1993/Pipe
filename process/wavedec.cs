using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;



namespace WindowsFormsApplication2_20130422
{
    public class wavedec
    {
        /*
         * 函数说明：根据小波名称，确定小波基参数
         * 输入：
         *      string wavename, 小波名称
         *      ref int dwt_mode, 小波基
         *      ref int len 小波基
         * 输出：
         *  无
         */
        private void dwt_mode_select(string wavename, ref int dwt_mode, ref int len)
        {
            int l = wavename.Length;
            
            string wave = wavename.Substring(0,l - 1);
            switch (wave)
            {
                case "db": dwt_mode = 1; break;
                case "coif": dwt_mode = 2; break;
                case "sym": dwt_mode = 3; break;
                default: break;
            }
            len = int.Parse (wavename.Substring(l-1,1));
            //string temp = wavename.Substring(l - 1, l);
           // len = int.Parse(temp);
        }
        /*
         * 函数说明：小波分解函数
         * 输入：
         *      double [] data_in,  待小波分解数据
         *      int N,  分解至第几层
         *      string wavename,  小波基
         *      ref double [] C, 分解后系数存放数组
         *      ref int [] L， 分解后系数长度数组
         * 输出： 
         *  无
         */
        public void wdec(double [] data_in, int N, string wavename, ref double [] C, ref int [] L)
        {
            int N_wavedec = N;
            int dwt_mode = 0;
            int len = 0;
            dwt_mode_select(wavename, ref dwt_mode, ref len);

            int sig_extend_mode = 1;
            int count = 0;

            double[] cA1 = new double[0];
            double[] cA2 = new double[0];
            double[] cA3 = new double[0];
            double[] cA4 = new double[0];
            double[] cA5 = new double[0];
           // double[] cA6 = new double[0];
           // double[] cA7 = new double[0];
           // double[] cA8 = new double[0];

            double[] cD1 = new double[0];
            double[] cD2 = new double[0];
            double[] cD3 = new double[0];
            double[] cD4 = new double[0];
            double[] cD5 = new double[0];
           // double[] cD6 = new double[0];
           // double[] cD7 = new double[0];
           // double[] cD8 = new double[0];

            switch (N_wavedec)
            {
                case 1:
                {
                    DWT(ref data_in,
                        ref cA1,
                        ref cD1,
                        ref dwt_mode,
                        ref len,
                        ref sig_extend_mode,
                        ref count);
                    C = new double[2 * cA1.Length];
                    for (int i = 0; i < cA1.Length; i++ )
                    {
                        C[i] = cA1[i];
                    }
                    for (int i = 0; i < cD1.Length; i++)
                    {
                        C[i + cA1.Length] = cD1[i];
                    }
                    L = new int[] { cA1.Length, cD1.Length, data_in.Length};
                    break;
                }
                case 2:
                {
                    DWT(ref data_in,
                        ref cA1,
                        ref cD1,
                        ref dwt_mode,
                        ref len,
                        ref sig_extend_mode,
                        ref count);
                    DWT(ref cA1,
                        ref cA2,
                        ref cD2,
                        ref dwt_mode,
                        ref len,
                        ref sig_extend_mode,
                        ref count);
                    C = new double[2 * cA2.Length + cD1.Length];
                    for (int i = 0; i < cA2.Length; i++)
                    {
                        C[i] = cA2[i];
                    }
                    for (int i = 0; i < cD2.Length; i++)
                    {
                        C[i + cA2.Length] = cD2[i];
                    }
                    for (int i = 0; i < cD1.Length; i++ )
                    {
                        C[i + 2 * cA2.Length] =cD1[i];
                    }
                    L = new int[] { cA2.Length, cD2.Length, cD1.Length, data_in.Length };
                    break;
                }
                case 3:
                {
                    DWT(ref data_in,
                        ref cA1,
                        ref cD1,
                        ref dwt_mode,
                        ref len,
                        ref sig_extend_mode,
                        ref count);
                    DWT(ref cA1,
                        ref cA2,
                        ref cD2,
                        ref dwt_mode,
                        ref len,
                        ref sig_extend_mode,
                        ref count);
                    DWT(ref cA2,
                        ref cA3,
                        ref cD3,
                        ref dwt_mode,
                        ref len,
                        ref sig_extend_mode,
                        ref count);
                    C = new double[2 * cA3.Length + cD2.Length + cD1.Length];
                    for (int i = 0; i < cA3.Length; i++)
                    {
                        C[i] = cA3[i];
                    }
                    for (int i = 0; i < cD3.Length; i++)
                    {
                        C[i + cA3.Length] = cD3[i];
                    }
                    for (int i = 0; i < cD2.Length; i++)
                    {
                        C[i + 2 * cA3.Length] = cD2[i];
                    }
                    for (int i = 0; i < cD1.Length; i++)
                    {
                        C[i + 2 * cA3.Length + cD2.Length] = cD1[i];
                    }
                    L = new int[] { cA3.Length, cD3.Length, cD2.Length, cD1.Length, data_in.Length };
                    break;
                }
                case 4:
                {
                    DWT(ref data_in,
                        ref cA1,
                        ref cD1,
                        ref dwt_mode,
                        ref len,
                        ref sig_extend_mode,
                        ref count);
                    DWT(ref cA1,
                        ref cA2,
                        ref cD2,
                        ref dwt_mode,
                        ref len,
                        ref sig_extend_mode,
                        ref count);
                    DWT(ref cA2,
                        ref cA3,
                        ref cD3,
                        ref dwt_mode,
                        ref len,
                        ref sig_extend_mode,
                        ref count);
                    DWT(ref cA3,
                        ref cA4,
                        ref cD4,
                        ref dwt_mode,
                        ref len,
                        ref sig_extend_mode,
                        ref count);
                    C = new double[2 * cA4.Length + cD3.Length + cD2.Length + cD1.Length];
                    for (int i = 0; i < cA4.Length; i++)
                    {
                        C[i] = cA4[i];
                    }
                    for (int i = 0; i < cD4.Length; i++)
                    {
                        C[i + cA4.Length] = cD4[i];
                    }
                    for (int i = 0; i < cD3.Length; i++)
                    {
                        C[i + 2 * cA4.Length] = cD3[i];
                    }
                    for (int i = 0; i < cD2.Length; i++)
                    {
                        C[i + 2 * cA4.Length + cD3.Length] = cD2[i];
                    }
                    for (int i = 0; i < cD1.Length; i++)
                    {
                        C[i + 2 * cA4.Length + cD3.Length + cD2.Length] = cD1[i];
                    }

                    L = new int[] { cA4.Length, cD4.Length, cD3.Length, cD2.Length, cD1.Length, data_in.Length };
                    break;
                }
                case 5:
                {
                    DWT(ref data_in,
                        ref cA1,
                        ref cD1,
                        ref dwt_mode,
                        ref len,
                        ref sig_extend_mode,
                        ref count);
                    DWT(ref cA1,
                        ref cA2,
                        ref cD2,
                        ref dwt_mode,
                        ref len,
                        ref sig_extend_mode,
                        ref count);
                    DWT(ref cA2,
                        ref cA3,
                        ref cD3,
                        ref dwt_mode,
                        ref len,
                        ref sig_extend_mode,
                        ref count);
                    DWT(ref cA3,
                        ref cA4,
                        ref cD4,
                        ref dwt_mode,
                        ref len,
                        ref sig_extend_mode,
                        ref count);
                    DWT(ref cA4,
                        ref cA5,
                        ref cD5,
                        ref dwt_mode,
                        ref len,
                        ref sig_extend_mode,
                        ref count);
                    C = new double[2 * cA5.Length + cD4.Length + cD3.Length + cD2.Length + cD1.Length];
                    for (int i = 0; i < cA5.Length; i++)
                    {
                        C[i] = cA5[i];
                    }
                    for (int i = 0; i < cD5.Length; i++)
                    {
                        C[i + cA5.Length] = cD5[i];
                    }
                    for (int i = 0; i < cD4.Length; i++)
                    {
                        C[i + 2 * cA5.Length] = cD4[i];
                    }
                    for (int i = 0; i < cD3.Length; i++)
                    {
                        C[i + 2 * cA5.Length + cD4.Length] = cD3[i];
                    }
                    for (int i = 0; i < cD2.Length; i++)
                    {
                        C[i + 2 * cA5.Length + cD4.Length + cD3.Length] = cD2[i];
                    }
                    for (int i = 0; i < cD1.Length; i++)
                    {
                        C[i + 2 * cA5.Length + cD4.Length + cD3.Length + cD2.Length] = cD1[i];
                    }

                    L = new int[] { cA5.Length, cD5.Length, cD4.Length, cD3.Length, cD2.Length, cD1.Length, data_in.Length };
                    break;
                }
                default: break;
            }
        }
        /*
         * 函数说明：单层小波分解函数
         * 输入：
         *             ref double[] data, 待分解数据
         *             ref double[] cA, 分解后近似系数数组
         *             ref double[] cD, 分解后细节系数数组
         *             ref int dwt_mode, 
         *             ref int len_n, 这两个参数决定小波基滤波器
         *             ref int sig_extend_mode, 延拓参数，为周期彦脱
         *             ref int count 保留字段
         * 输出：
         *  无
         *      
         */
        private void DWT(ref double[] data,
                        ref double[] cA,
                        ref double[] cD,
                        ref int dwt_mode,
                        ref int len_n,
                        ref int sig_extend_mode,
                        ref int count)
        {
            double [] data_in = new double[0];
            double [] Lo_D = new double[0];
            double [] Hi_D = new double[0];

            data_in = data;

            switch(dwt_mode)
            {
                case 1:
                    Lo_D = new double[2 * len_n];
                    Hi_D = new double[2 * len_n];
                    Daubechies_coefficient(len_n, ref Lo_D, ref Hi_D);
                    break;
                case 2: 
                    Lo_D = new double[6 * len_n];
                    Hi_D = new double[6 * len_n];
                    Coiflets_coefficient(len_n, ref Lo_D, ref Hi_D);
                    break;
                case 3:
                    Lo_D = new double[2 * len_n];
                    Hi_D = new double[2 * len_n];
                    Symlets_coefficient(len_n, ref Lo_D, ref Hi_D);
                    break;
            }

            int lf = Lo_D.Length;
            int Sin_le = lf - 1;
            double [] data_extend = new double[0];

            data_extend = extend_per(ref data_in, ref Sin_le);

            double[] result_cA1;
            double[] result_cD1;
            result_cA1 = Conv(ref data_extend, ref Lo_D);
            result_cD1 = Conv(ref data_extend, ref Hi_D);
            int result_len = result_cA1.Length / 2;
            double[] result_cA = new double[result_len];
            double[] result_cD = new double[result_len];
            for (int i = 0; i < result_len; i++)
            {
                result_cA[i] = result_cA1[1 + 2 * i];
            }
            for (int i = 0; i < result_len; i++)
            {
                result_cD[i] = result_cD1[1 + 2 * i];
            }
            cA = result_cA;
            cD = result_cD;
        }

        /*
         *  函数说明：根据N选择db的分解高通、低通滤波系数
         *  输入：
         *       int N ： 选择小波基
         *       ref double[] Lo_Rref ：分解低通滤波系数
         *       double[] Hi_R ： 分解高通滤波系数
         *  输出：
         *       无
         */
        private static void Daubechies_coefficient(int N, ref double[] Lo_D, ref double[] Hi_D)
        {
            double[] Lo_D1 = new double[2 * N];
            double[] Hi_D1 = new double[2 * N];
            switch (N)
            {
                case 1: Lo_D1 = new double[] { 0.707106781186548, 0.707106781186548 }; Hi_D1 = new double[] { -0.707106781186548, 0.707106781186548 }; break;
                case 2: Lo_D1 = new double[] { -0.129409522550921, 0.224143868041857, 0.836516303737469, 0.482962913144690 }; Hi_D1 = new double[] { -0.482962913144690, 0.836516303737469, -0.224143868041857, -0.129409522550921 }; break;
                case 3: Lo_D1 = new double[] { 0.035226291882101, -0.085441273882241, -0.135011020010391, 0.459877502119331, 0.806891509313339, 0.332670552950957 }; Hi_D1 = new double[] { -0.332670552950957, 0.806891509313339, -0.459877502119331, -0.135011020010391, 0.085441273882241, 0.035226291882101 }; break;
                case 4: Lo_D1 = new double[] { -0.010597401784997, 0.032883011666983, 0.030841381835987, -0.187034811718881, -0.027983769416984, 0.630880767929590, 0.714846570552542, 0.230377813308855 }; Hi_D1 = new double[] { -0.230377813308855, 0.714846570552542, -0.630880767929590, -0.027983769416984, 0.187034811718881, 0.030841381835987, -0.032883011666983, -0.010597401784997 }; break;
                case 5: Lo_D1 = new double[] { 0.003335725285002, -0.012580751999016, -0.006241490213012, 0.077571493840065, -0.032244869585030, -0.242294887066190, 0.138428145901103, 0.724308528438574, 0.603829269797473, 0.160102397974125 }; Hi_D1 = new double[] { -0.160102397974125, 0.603829269797473, -0.724308528438574, 0.138428145901103, 0.242294887066190, -0.032244869585030, -0.077571493840065, -0.006241490213012, 0.012580751999016, 0.003335725285002 }; break;
                case 6: Lo_D1 = new double[] { -0.001077301084996, 0.004777257511011, 0.000553842200994, -0.031582039318031, 0.027522865530016, 0.097501605587079, -0.129766867567096, -0.226264693965169, 0.315250351709243, 0.751133908021578, 0.494623890398385, 0.111540743350080 }; Hi_D1 = new double[] { -0.111540743350080, 0.494623890398385, -0.751133908021578, 0.315250351709243, 0.226264693965169, -0.129766867567096, -0.097501605587079, 0.027522865530016, 0.031582039318031, 0.000553842200994, -0.004777257511011, -0.001077301084996 }; break;
                case 7: Lo_D1 = new double[] { 0.000353713800001, -0.001801640704000, 0.000429577973005, 0.012550998556014, -0.016574541631016, -0.038029936935035, 0.080612609151066, 0.071309219267050, -0.224036184994166, -0.143906003929106, 0.469782287405359, 0.729132090846555, 0.396539319482306, 0.077852054085062 }; Hi_D1 = new double[] { -0.077852054085062, 0.396539319482306, -0.729132090846555, 0.469782287405359, 0.143906003929106, -0.224036184994166, -0.071309219267050, 0.080612609151066, 0.038029936935035, -0.016574541631016, -0.012550998556014, 0.000429577973005, 0.001801640704000, 0.000353713800001 }; break;
                case 8: Lo_D1 = new double[] { -0.000117476784002, 0.000675449405999, -0.000391740372996, -0.004870352993011, 0.008746094047016, 0.013981027917016, -0.044088253931065, -0.017369301002022, 0.128747426620186, 0.000472484573998, -0.284015542962428, -0.015829105256024, 0.585354683654869, 0.675630736298013, 0.312871590914466, 0.054415842243082 }; Hi_D1 = new double[] { -0.054415842243082, 0.312871590914466, -0.675630736298013, 0.585354683654869, 0.015829105256024, -0.284015542962428, -0.000472484573998, 0.128747426620186, 0.017369301002022, -0.044088253931065, -0.013981027917016, 0.008746094047016, 0.004870352993011, -0.000391740372996, -0.000675449405999, -0.000117476784002 }; break;
                case 9: Lo_D1 = new double[] { 0.000039347319995, -0.000251963188998, 0.000230385763995, 0.001847646882961, -0.004281503681905, -0.004723204757895, 0.022361662123515, 0.000250947114992, -0.067632829059524, 0.030725681478323, 0.148540749334760, -0.096840783220879, -0.293273783272587, 0.133197385822089, 0.657288078036639, 0.604823123676779, 0.243834674637667, 0.038077947363167 }; Hi_D1 = new double[] { -0.038077947363167, 0.243834674637667, -0.604823123676779, 0.657288078036639, -0.133197385822089, -0.293273783272587, 0.096840783220879, 0.148540749334760, -0.030725681478323, -0.067632829059524, -0.000250947114992, 0.022361662123515, 0.004723204757895, -0.004281503681905, -0.001847646882961, 0.000230385763995, 0.000251963188998, 0.000039347319995 }; break;
                case 10: Lo_D1 = new double[] { -0.000013264203002, 0.000093588670001, -0.000116466854994, -0.000685856695005, 0.001992405294991, 0.001395351746994, -0.010733175482980, 0.003606553566988, 0.033212674058933, -0.029457536821946, -0.071394147165861, 0.093057364603807, 0.127369340335743, -0.195946274376597, -0.249846424326489, 0.281172343660426, 0.688459039452592, 0.527201188930920, 0.188176800077621, 0.026670057900951 }; Hi_D1 = new double[] { -0.026670057900951, 0.188176800077621, -0.527201188930920, 0.688459039452592, -0.281172343660426, -0.249846424326489, 0.195946274376597, 0.127369340335743, -0.093057364603807, -0.071394147165861, 0.029457536821946, 0.033212674058933, -0.003606553566988, -0.010733175482980, -0.001395351746994, 0.001992405294991, 0.000685856695005, -0.000116466854994, -0.000093588670001, -0.000013264203002 }; break;
                default:break;
            }
            Lo_D = Lo_D1;
            Hi_D = Hi_D1;
        }
        /*
         *  函数说明：根据N选择db的分解高通、低通滤波系数
         *  输入：
         *       int N ： 选择小波基
         *       ref double[] Lo_Rref ：分解低通滤波系数
         *       double[] Hi_R ： 分解高通滤波系数
         *  输出：
         *       无
         */
        private static void Coiflets_coefficient(int N, ref double[] Lo_D, ref double[] Hi_D)
        {
            double[] Lo_D1 = new double[6 * N];
            double[] Hi_D1 = new double[6 * N];
            switch (N)
            {
                case 1: Lo_D1 = new double[] { -0.015655728135465, -0.072732619512854, 0.384864846864203, 0.852572020212255, 0.337897662457809, -0.072732619512854 }; Hi_D1 = new double[] { 0.072732619512854, 0.337897662457809, -0.852572020212255, 0.384864846864203, 0.072732619512854, -0.015655728135465 }; break;
                case 2: Lo_D1 = new double[] { -0.000720549445365, -0.001823208870703, 0.005611434819394, 0.023680171946334, -0.059434418646457, -0.076488599078306, 0.417005184421693, 0.812723635445542, 0.386110066821162, -0.067372554721963, -0.041464936781759, 0.016387336463522 }; Hi_D1 = new double[] { -0.016387336463522, -0.041464936781759, 0.067372554721963, 0.386110066821162, -0.812723635445542, 0.417005184421693, 0.076488599078306, -0.059434418646457, -0.023680171946334, 0.005611434819394, 0.001823208870703, -0.000720549445365 }; break;
                case 3: Lo_D1 = new double[] { -0.000034599772836, -0.000070983303138, 0.000466216960113, 0.001117518770891, -0.002574517688750, -0.009007976136662, 0.015880544863616, 0.034555027573062, -0.082301927106886, -0.071799821619312, 0.428483476377619, 0.793777222625621, 0.405176902409617, -0.061123390002673, -0.065771911281856, 0.023452696141836, 0.007782596427325, -0.003793512864491 }; Hi_D1 = new double[] { 0.003793512864491, 0.007782596427325, -0.023452696141836, -0.065771911281856, 0.061123390002673, 0.405176902409617, -0.793777222625621, 0.428483476377619, 0.071799821619312, -0.082301927106886, -0.034555027573062, 0.015880544863616, 0.009007976136662, -0.002574517688750, -0.001117518770891, 0.000466216960113, 0.000070983303138, -0.000034599772836 }; break;
                case 4: Lo_D1 = new double[] { -0.000001784985003, -0.000003259680237, 0.000031229875865, 0.000062339034461, -0.000259974552488, -0.000589020756244, 0.001266561929299, 0.003751436157278, -0.005658286686611, -0.015211731527946, 0.025082261844864, 0.039334427123337, -0.096220442033988, -0.066627474263425, 0.434386056491469, 0.782238930920499, 0.415308407030430, -0.056077313316755, -0.081266699680879, 0.026682300156053, 0.016068943964776, -0.007346166327642, -0.001629492012602, 0.000892313668582 }; Hi_D1 = new double[] { -0.000892313668582, -0.001629492012602, 0.007346166327642, 0.016068943964776, -0.026682300156053, -0.081266699680879, 0.056077313316755, 0.415308407030430, -0.782238930920499, 0.434386056491469, 0.066627474263425, -0.096220442033988, -0.039334427123337, 0.025082261844864, 0.015211731527946, -0.00565828668661, -0.003751436157278, 0.001266561929299, 0.000589020756244, -0.000259974552488, -0.000062339034461, 0.000031229875865, 0.000003259680237, -0.000001784985003 }; break;
                case 5: Lo_D1 = new double[] { -0.000000095176573, -0.000000167442886, 0.000002063761851, 0.000003734655175, -0.000021315026810, -0.000041340432273, 0.000140541149702, 0.000302259581813, -0.000638131343045, -0.001662863702013, 0.002433373212658, 0.006764185448053, -0.009164231162482, -0.019761778942573, 0.032683574267112, 0.041289208750182, -0.105574208703339, -0.062035963962904, 0.437991626171837, 0.774289603652956, 0.421566206690851, -0.052043163176244, -0.091920010559696, 0.028168028970936, 0.023408156785839, -0.010131117519850, -0.004159358781386, 0.002178236358109, 0.000358589687896, -0.000212080839804 }; Hi_D1 = new double[] { 0.000212080839804, 0.000358589687896, -0.002178236358109, -0.004159358781386, 0.010131117519850, 0.023408156785839, -0.028168028970936, -0.091920010559696, 0.052043163176244, 0.421566206690851, -0.774289603652956, 0.437991626171837, 0.062035963962904, -0.105574208703339, -0.041289208750182, 0.032683574267112, 0.019761778942573, -0.009164231162482, -0.006764185448053, 0.002433373212658, 0.001662863702013, -0.000638131343045, -0.000302259581813, 0.000140541149702, 0.000041340432273, -0.000021315026810, -0.000003734655175, 0.000002063761851, 0.000000167442886, -0.000000095176573 }; break;
                default:break;
            }
            Lo_D = Lo_D1;
            Hi_D = Hi_D1;
        }
        /*
         *  函数说明：根据N选择sym的分解高通、低通滤波系数
         *  输入：
         *       int N ： 选择小波基
         *       ref double[] Lo_Rref ：分解低通滤波系数
         *       double[] Hi_R ： 分解高通滤波系数
         *  输出：
         *       无
         */
        private static void Symlets_coefficient(int N, ref double[] Lo_D, ref double[] Hi_D)
        {
            double[] Lo_D1 = new double[2 * N];
            double[] Hi_D1 = new double[2 * N];
            switch (N)
            {
                case 2: Lo_D1 = new double[] { -0.129409522550921, 0.224143868041857, 0.836516303737469, 0.482962913144690 }; Hi_D1 = new double[] { -0.482962913144690, 0.836516303737469, -0.224143868041857, -0.129409522550921 }; break;
                case 3: Lo_D1 = new double[] { 0.035226291882101, -0.085441273882241, -0.135011020010391, 0.459877502119331, 0.806891509313339, 0.332670552950957 }; Hi_D1 = new double[] { -0.332670552950957, 0.806891509313339, -0.459877502119331, -0.135011020010391, 0.085441273882241, 0.035226291882101 }; break;
                case 4: Lo_D1 = new double[] { -0.075765714789273, -0.029635527645999, 0.497618667632015, 0.803738751805916, 0.297857795605277, -0.099219543576847, -0.012603967262038, 0.032223100604043 }; Hi_D1 = new double[] { -0.032223100604043, -0.012603967262038, 0.099219543576847, 0.297857795605277, -0.803738751805916, 0.497618667632015, 0.029635527645999, -0.075765714789273 }; break;
                case 5: Lo_D1 = new double[] { 0.027333068345078, 0.029519490925775, -0.039134249302383, 0.199397533977394, 0.723407690402421, 0.633978963458212, 0.016602105764522, -0.175328089908450, -0.021101834024759, 0.019538882735287 }; Hi_D1 = new double[] { -0.019538882735287, -0.021101834024759, 0.175328089908450, 0.016602105764522, -0.633978963458212, 0.723407690402421, -0.199397533977394, -0.039134249302383, -0.029519490925775, 0.027333068345078 }; break;
                case 6: Lo_D1 = new double[] { 0.015404109327027, 0.003490712084217, -0.117990111148191, -0.048311742585633, 0.491055941926747, 0.787641141030194, 0.337929421727622, -0.072637522786463, -0.021060292512301, 0.044724901770666, 0.001767711864243, -0.007800708325034 }; Hi_D1 = new double[] { 0.007800708325034, 0.001767711864243, -0.044724901770666, -0.021060292512301, 0.072637522786463, 0.337929421727622, -0.787641141030194, 0.491055941926747, 0.048311742585633, -0.117990111148191, -0.003490712084217, 0.015404109327027 }; break;
                case 7: Lo_D1 = new double[] { 0.002681814568258, -0.001047384888683, -0.012636303403252, 0.030515513165964, 0.067892693501373, -0.049552834937127, 0.017441255086856, 0.536101917091763, 0.767764317003164, 0.288629631751515, -0.140047240442962, -0.107808237703818, 0.004010244871534, 0.010268176708511 }; Hi_D1 = new double[] { -0.010268176708511, 0.004010244871534, 0.107808237703818, -0.140047240442962, -0.288629631751515, 0.767764317003164, -0.536101917091763, 0.017441255086856, 0.049552834937127, 0.067892693501373, -0.030515513165964, -0.012636303403252, 0.001047384888683, 0.002681814568258 }; break;
                case 8: Lo_D1 = new double[] { -0.003382415951006, -0.000542132331791, 0.031695087811493, 0.007607487324918, -0.143294238350810, -0.061273359067659, 0.481359651258372, 0.777185751700524, 0.364441894835331, -0.051945838107709, -0.027219029917056, 0.049137179673608, 0.003808752013891, -0.014952258337048, -0.000302920514721, 0.001889950332759 }; Hi_D1 = new double[] { -0.001889950332759, -0.000302920514721, 0.014952258337048, 0.003808752013891, -0.049137179673608, -0.027219029917056, 0.051945838107709, 0.364441894835331, -0.777185751700524, 0.481359651258372, 0.061273359067659, -0.143294238350810, -0.007607487324918, 0.031695087811493, 0.000542132331791, -0.003382415951006 }; break;
                case 9: Lo_D1 = new double[] { 0.001400915525915, 0.000619780888986, -0.013271967781817, -0.011528210207679, 0.030224878858275, 0.000583462746125, -0.054568958430835, 0.238760914607304, 0.717897082764413, 0.617338449140936, 0.035272488035272, -0.191550831297285, -0.018233770779395, 0.062077789302886, 0.008859267493400, -0.010264064027633, -0.000473154498680, 0.001069490032909 }; Hi_D1 = new double[] { -0.001069490032909 - 0.000473154498680, 0.010264064027633, 0.008859267493400, -0.062077789302886, -0.018233770779395, 0.191550831297285, 0.035272488035272, -0.617338449140936, 0.717897082764413, -0.238760914607304, -0.054568958430835, -0.000583462746125, 0.030224878858275, 0.011528210207679, -0.013271967781817, -0.000619780888986, 0.001400915525915 }; break;
                case 10: Lo_D1 = new double[] { 0.000770159809114, 0.000095632670723, -0.008641299277022, -0.001465382581304, 0.045927239231092, 0.011609893903711, -0.159494278884910, -0.070880535783227, 0.471690666938450, 0.769510037021100, 0.383826761067071, -0.035536740473826, -0.031990056882431, 0.049994972077375, 0.005764912033581, -0.020354939812311, -0.000804358932016, 0.004593173585312, 0.000057036083618, -0.000459329421005 }; Hi_D1 = new double[] { 0.000459329421005, 0.000057036083618, -0.004593173585312, -0.000804358932016, 0.020354939812311, 0.005764912033581, -0.049994972077375, -0.031990056882431, 0.035536740473826, 0.383826761067071, -0.769510037021100, 0.471690666938450, 0.070880535783227, -0.159494278884910, -0.011609893903711, 0.045927239231092, 0.001465382581304, -0.008641299277022, -0.000095632670723, 0.000770159809114 }; break;
                default:break;
            }
            Lo_D = Lo_D1;
            Hi_D = Hi_D1;
        }

        /*
         * 函数说明：对信号进行周期延拓后，取（信号长度+2*len）长度信号，信号组成为：原信号最后len个点 + 原信号 + 原信号初始len个点
         *              若len小于1，直接返回原始信号。若信号长度为奇数，补齐至偶数个点。
         *  输入：
         *      ref double[] SIGNAL ： 原始信号序列
         *      ref int len ： 需要取得len长度
         *  输出：
         *      返回延拓后信号
         */
        private static double[] extend_per(ref double[] SIGNAL, ref int len)
        {
            int len1 = SIGNAL.Length;
            double[] SIGNAL_1;
            if (len1 % 2 != 0)
            {
                SIGNAL_1 = new double[len1 + 1];
                for (int i = 0; i < len1; i++)
                {
                    SIGNAL_1[i] = SIGNAL[i];
                }
                SIGNAL_1[len1] = SIGNAL[len1 - 1];
            }
            else
            {
                SIGNAL_1 = new double[len1];
                SIGNAL_1 = SIGNAL;
            }
            int Len_SIG = SIGNAL_1.Length;

            double[] temp = new double[Len_SIG + len * 2];
            if (len < 1)
                return SIGNAL_1;
            else
            {
                for (int i = 0; i < len; i++)
                {
                    temp[i] = SIGNAL_1[Len_SIG - len + i];
                }
                for (int i = 0; i < Len_SIG; i++)
                {
                    temp[i + len] = SIGNAL_1[i];
                }
                for (int i = 0; i < len; i++)
                {
                    temp[i + len + Len_SIG] = SIGNAL_1[i];
                }
            }
            return temp;
        }

        /*
         * 函数说明：卷积函数
         * 输入：（假设原始信号长度为len_sig）
         *      ref double[] signal, 延拓后信号，长度为len_sig + 2 * (N - 1)
         *      ref double[] filters, 滤波器长度为N
         * 输出：
         *      返回卷积后的数组，长度为：len_sig + 2 * (N - 1) - N + 1 = len_sig + N - 1
         */
        private static double[] Conv(ref double[] signal, ref double[] filters)
        {
            int len1 = signal.Length;
            int len2 = filters.Length;
            int len = len1 - len2 + 1;
            double[] result = new double[len];
            for (int i = 0; i < len; i++)
            {
                double flags = 0;
                for (int j = 0; j < len2; j++)
                {
                    flags += signal[i + j] * filters[len2 - 1 - j];
                }
                result[i] = flags;
            }
            return result;
        }

        public void threshold(ref double[] c, ref int [] l, string method)
        {
            int len = l.Length;
            int N = l[len - 1];
            double threshold = new double();
            switch (method)
            {
                case "sqtwolog":
                    {
                        threshold = Math.Sqrt(2 * Math.Log(N));
                        int start = l[0];
                        for (int i = start; i < c.Length; i++)
                        {
                            if (c[i] < threshold && c[i] > -threshold)
                            {
                                c[i] = 0;
                            }
                            else
                            {
                                c[i] += (c[i] > 0) ? (threshold) : (-threshold);
                            }
                        }
                        break;
                    }
                default: break;
            }
        }
    }
}
